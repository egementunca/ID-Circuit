"""
Post Processor for Identity Circuit Factory.

Handles circuit simplification and manages relationships between dimension groups:
- Swap and cancellation reduction
- Template-based simplification
- Cross-dimension group relationships
- Metrics computation
"""

import logging
from typing import List, Tuple, Optional, Dict, Any
from dataclasses import dataclass
import time

from .database import CircuitDatabase, CircuitRecord
from sat_revsynth.circuit.circuit import Circuit

logger = logging.getLogger(__name__)

@dataclass
class SimplificationResult:
    """Result of circuit simplification."""
    success: bool
    original_circuit_id: Optional[int] = None
    simplified_circuit_id: Optional[int] = None
    target_dim_group_id: Optional[int] = None
    reduction_metrics: Optional[Dict[str, Any]] = None
    simplification_type: Optional[str] = None
    error_message: Optional[str] = None

class PostProcessor:
    """Handles circuit simplification and post-processing operations."""
    
    def __init__(self, database: CircuitDatabase):
        self.db = database
    
    def simplify_circuit(self, circuit_id: int, 
                        simplification_types: Optional[List[str]] = None) -> SimplificationResult:
        """
        Simplify a circuit using various reduction techniques.
        
        Args:
            circuit_id: ID of the circuit to simplify
            simplification_types: List of simplification types to apply
            
        Returns:
            SimplificationResult with details about the simplification
        """
        logger.info(f"Simplifying circuit {circuit_id}")
        
        # Get the circuit
        circuit_record = self.db.get_circuit(circuit_id)
        if not circuit_record:
            return SimplificationResult(
                success=False,
                error_message=f"Circuit {circuit_id} not found"
            )
        
        # Convert to sat_revsynth Circuit
        circuit = self._gates_to_circuit(circuit_record.gates, circuit_record.width)
        
        # Apply simplifications
        simplification_types = simplification_types or ["swap_cancel"]
        
        for sim_type in simplification_types:
            try:
                if sim_type == "swap_cancel":
                    result = self._apply_swap_cancellation(circuit, circuit_id)
                elif sim_type == "template":
                    result = self._apply_template_simplification(circuit, circuit_id)
                else:
                    logger.warning(f"Unknown simplification type: {sim_type}")
                    continue
                
                if result.success:
                    return result
                    
            except Exception as e:
                logger.error(f"Simplification {sim_type} failed: {e}")
                continue
        
        # If no simplification worked, return the original circuit
        return SimplificationResult(
            success=True,
            original_circuit_id=circuit_id,
            simplified_circuit_id=circuit_id,
            simplification_type="none"
        )
    
    def _apply_swap_cancellation(self, circuit: Circuit, 
                                original_circuit_id: int) -> SimplificationResult:
        """Apply swap and cancellation reduction."""
        start_time = time.time()
        
        # Create a copy for reduction
        reduced_circuit, metrics = circuit.reduce_by_swaps_and_cancellation()
        
        # Check if reduction actually simplified the circuit
        if len(reduced_circuit) >= len(circuit):
            return SimplificationResult(
                success=False,
                error_message="No reduction achieved"
            )
        
        # Store the simplified circuit
        try:
            gates = self._circuit_to_gates(reduced_circuit)
            
            circuit_record = CircuitRecord(
                id=None,
                width=reduced_circuit.width(),
                gate_count=len(reduced_circuit),
                gates=gates,
                permutation=list(range(1 << reduced_circuit.width())),
                complexity_walk=None,
                dim_group_id=None  # Will be set by database if needed
            )
            
            simplified_circuit_id = self.db.store_circuit(circuit_record)
            
            # Find or create target dimension group
            target_dim_group = self.db.get_dim_group(reduced_circuit.width(), len(reduced_circuit))
            if not target_dim_group:
                # Create new dimension group for the simplified circuit
                from .database import DimGroupRecord
                dim_group_record = DimGroupRecord(
                    id=None,
                    width=reduced_circuit.width(),
                    length=len(reduced_circuit),
                    seed_circuit_id=simplified_circuit_id,
                    representative_circuit_id=simplified_circuit_id,
                    total_equivalents=1
                )
                
                target_dim_group_id = self.db.store_dim_group(dim_group_record)
                
                # Store the simplified circuit as equivalent of itself
                self.db.store_equivalent(
                    circuit_id=simplified_circuit_id,
                    dim_group_id=target_dim_group_id,
                    parent_seed_id=simplified_circuit_id,
                    unroll_type="simplified",
                    unroll_params={"original_circuit_id": original_circuit_id}
                )
            else:
                target_dim_group_id = target_dim_group.id
                
                # Store the simplified circuit in the existing dimension group
                self.db.store_equivalent(
                    circuit_id=simplified_circuit_id,
                    dim_group_id=target_dim_group_id,
                    parent_seed_id=target_dim_group.seed_circuit_id,
                    unroll_type="simplified",
                    unroll_params={"original_circuit_id": original_circuit_id}
                )
            
            # Store simplification record
            metrics["processing_time"] = time.time() - start_time
            self.db.store_simplification(
                original_id=original_circuit_id,
                simplified_id=simplified_circuit_id,
                target_dim_group_id=target_dim_group_id,
                metrics=metrics,
                simplification_type="swap_cancel"
            )
            
            return SimplificationResult(
                success=True,
                original_circuit_id=original_circuit_id,
                simplified_circuit_id=simplified_circuit_id,
                target_dim_group_id=target_dim_group_id,
                reduction_metrics=metrics,
                simplification_type="swap_cancel"
            )
            
        except Exception as e:
            return SimplificationResult(
                success=False,
                error_message=f"Failed to store simplified circuit: {e}"
            )
    
    def _apply_template_simplification(self, circuit: Circuit, 
                                     original_circuit_id: int) -> SimplificationResult:
        """Apply template-based simplification (placeholder for future implementation)."""
        # This is a placeholder for template-based simplification
        # Could implement pattern matching against known identity templates
        logger.info("Template simplification not yet implemented")
        return SimplificationResult(
            success=False,
            error_message="Template simplification not implemented"
        )
    
    def simplify_dimension_group(self, dim_group_id: int, 
                               simplification_types: Optional[List[str]] = None) -> Dict[int, SimplificationResult]:
        """Simplify all circuits in a dimension group."""
        logger.info(f"Simplifying dimension group {dim_group_id}")
        
        # Get all circuits in the dimension group
        circuit_data = self.db.get_equivalents_for_dim_group(dim_group_id)
        results = {}
        
        for circuit_info in circuit_data:
            circuit_id = circuit_info['circuit_id']
            logger.info(f"Simplifying circuit {circuit_id}")
            result = self.simplify_circuit(circuit_id, simplification_types)
            results[circuit_id] = result
            
            if not result.success:
                logger.error(f"Failed to simplify circuit {circuit_id}: {result.error_message}")
        
        return results
    
    def simplify_all_circuits(self, simplification_types: Optional[List[str]] = None) -> Dict[int, Dict[int, SimplificationResult]]:
        """Simplify all circuits in all dimension groups."""
        dim_groups = self.db.get_all_dim_groups()
        all_results = {}
        
        for dim_group in dim_groups:
            logger.info(f"Simplifying dimension group ({dim_group.width}, {dim_group.length})")
            results = self.simplify_dimension_group(dim_group.id, simplification_types)
            all_results[dim_group.id] = results
        
        return all_results
    
    def _gates_to_circuit(self, gates: List[Tuple], width: int) -> Circuit:
        """Convert gate list to sat_revsynth Circuit."""
        circuit = Circuit(width)
        
        for gate in gates:
            gate_type = gate[0]
            if gate_type == "NOT":
                circuit.x(gate[1], inplace=True)
            elif gate_type == "CNOT":
                circuit.cx(gate[1], gate[2], inplace=True)
            elif gate_type == "TOFFOLI":
                circuit.mcx([gate[1], gate[2]], gate[3], inplace=True)
        
        return circuit
    
    def _circuit_to_gates(self, circuit: Circuit) -> List[Tuple]:
        """Convert sat_revsynth Circuit to gate list."""
        gates = []
        
        for controls, target in circuit.gates():
            if len(controls) == 0:
                gates.append(("NOT", target))
            elif len(controls) == 1:
                gates.append(("CNOT", controls[0], target))
            elif len(controls) == 2:
                gates.append(("TOFFOLI", controls[0], controls[1], target))
            else:
                # Handle multi-controlled gates (convert to TOFFOLI chains)
                for i in range(len(controls) - 1):
                    gates.append(("TOFFOLI", controls[i], controls[i+1], target))
        
        return gates
    
    def get_simplification_stats(self) -> Dict[str, Any]:
        """Get statistics about simplification operations."""
        dim_groups = self.db.get_all_dim_groups()
        
        stats = {
            "total_dim_groups": len(dim_groups),
            "total_circuits": sum(dg.total_equivalents for dg in dim_groups),
            "simplification_types": {},
            "average_reduction": 0,
            "total_reductions": 0
        }
        
        # This would need to query the simplifications table
        # For now, return basic stats
        return stats
    
    def find_cross_dimension_relationships(self) -> Dict[str, List[Tuple[int, int]]]:
        """Find relationships between different dimension groups through simplification."""
        # This would analyze the simplifications table to find circuits
        # that simplify to circuits in different dimension groups
        relationships = {
            "simplifications": [],
            "extensions": [],
            "reductions": []
        }
        
        # Implementation would query the simplifications table
        # and analyze target_dim_group_id vs original circuit's dim_group_id
        
        return relationships 